<?php

/**
 * @file
 * Code for the PW Globals feature.
 */
include_once 'pw_globals.features.inc';

define('PW_GLOBALS_API_USER_RID', 29859578);
define('PW_GLOBALS_ADMINISTRATOR_RID', 30037204);
define('PW_GLOBALS_BLOCK_MANAGER_RID', 127500594);
define('PW_GLOBALS_CONTENT_MANAGER_RID', 51622513);
define('PW_GLOBALS_POLITICIAN_RID', 181527986);
define('PW_GLOBALS_CANDIDATE_RID', 185431326);
define('PW_GLOBALS_DEPUTY_RID', 140336230);
define('PW_GLOBALS_POLITICIAN_TID', 7027);
define('PW_GLOBALS_DEPUTY_TID', 7028);
define('PW_GLOBALS_CANDIDATE_TID', 7029);


/**
 * Implements hook_menu().
 *
 * @return array
 */
function pw_globals_menu() {
  $items['admin/config/pw'] = [
    'title' => 'Parliamentwatch',
    'description' => 'Custom settings for Parliamentwatch.',
    'access arguments' => ['administer site configuration'],
    'type' => MENU_NORMAL_ITEM,
  ];
  $items['info'] = [
    'title' => 'Info',
    'page callback' => 'pw_globals_info_page',
    'access arguments' => ['access content'],
    'type' => MENU_CALLBACK,
  ];
  $items['test'] = [
    'title' => 'Test',
    'page callback' => 'pw_globals_test_page',
    'access arguments' => ['administer site configuration'],
    'type' => MENU_CALLBACK,
  ];
  $items['solr-search/politician-index'] = [
    'title' => 'Search results',
    'page callback' => 'pw_globals_politician_search_page',
    'access arguments' => ['access content'],
    'type' => MENU_CALLBACK,
  ];
  $items['images/membership-count.txt'] = [
    'title' => 'Membeship count',
    'page callback' => 'pw_globals_membership_count',
    'access arguments' => ['access content'],
    'type' => MENU_CALLBACK,
  ];
  return $items;
}

/**
 * Implements hook_entity_info_alter().
 */
function pw_globals_entity_info_alter(&$entity_info) {
  $entity_info['node']['view modes']['tile'] = array(
    'label' => t('Tile'),
    'custom settings' => FALSE,
  );
  $entity_info['node']['view modes']['list_item'] = array(
    'label' => t('List item'),
    'custom settings' => FALSE,
  );
  $entity_info['node']['view modes']['embedded'] = array(
    'label' => t('Embedded'),
    'custom settings' => FALSE,
  );
  $entity_info['node']['view modes']['tabular'] = array(
    'label' => t('Tabular'),
    'custom settings' => FALSE,
  );
  $entity_info['node']['view modes']['timeline'] = array(
    'label' => t('Timeline'),
    'custom settings' => FALSE,
  );
  $entity_info['comment']['view modes']['tile'] = array(
    'label' => t('Tile'),
    'custom settings' => FALSE,
  );
  $entity_info['comment']['view modes']['embedded'] = array(
    'label' => t('Embedded'),
    'custom settings' => FALSE,
  );
}

/**
 * Implements hook_form_alter().
 */
function pw_globals_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'webform_client_form_6313') {
    $form['submitted']['user_agent']['#value'] = $_SERVER['HTTP_USER_AGENT'];
    $form['submitted']['referrer']['#value'] = $_SERVER['HTTP_REFERER'];
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function pw_globals_form_pw_globals_politician_search_form_alter(&$form, &$form_state) {
  $form['form_build_id']['#access'] = FALSE;
  $form['form_token']['#access'] = FALSE;
  $form['form_id']['#access'] = FALSE;
}

/**
 * Implements hook_block_info().
 */
function pw_globals_block_info() {
  $blocks['comments'] = [
    'info' => t('Comments'),
    'cache' => DRUPAL_NO_CACHE,
  ];
  $blocks['title'] = [
    'info' => t('Title'),
    'cache' => DRUPAL_NO_CACHE,
  ];
  $blocks['term_switcher'] = [
    'info' => 'Legislative term switcher',
    'cache' => DRUPAL_NO_CACHE,
  ];
  $blocks['politician_search_form'] = [
    'info' => 'Politician search form',
    'cache' => DRUPAL_NO_CACHE,
  ];
  $blocks['parliament_patron'] = [
    'info' => 'Parliament patron teaser',
    'cache' => DRUPAL_CACHE_PER_ROLE | DRUPAL_CACHE_PER_PAGE,
  ];
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function pw_globals_block_view($delta = '') {
  switch ($delta) {
    case 'comments':
      return pw_globals_comments_block();
    case 'title':
      return pw_globals_title_block();
    case 'term_switcher':
      return pw_globals_term_switcher_block();
    case 'politician_search_form':
      return pw_globals_politician_search_form_block();
    case 'parliament_patron':
      return pw_globals_parliament_patron_block();
    default:
      return [];
  }
}

/**
 * Page callback: Renders a page that demonstrates visual elements.
 */
function pw_globals_test_page() {
  return 'Lorem ipsum dolor sit...';
}

/**
 * Page callback: Displays listing of nodes in info menu.
 */
function pw_globals_info_page() {
  $build = [];
  $build['#theme_wrappers'] = ['container__tiles'];

  foreach (menu_tree_page_data('info-menu') as $link) {
    $node = node_load(substr($link['link']['link_path'], 5));
    $build[$node->nid][] = [
      '#theme' => 'html_tag',
      '#tag' => 'h2',
      '#value' => check_plain($node->title)
    ];

    foreach ($link['below'] as $child) {
      $build[$node->nid][] = node_view(node_load(substr($child['link']['link_path'], 5)), 'tile');
    }
  }

  return $build;
}

/**
 * Page callback: Displays results of politician search.
 */
function pw_globals_politician_search_page() {
  $limit = 12;
  $q = search_api_query('politician_archive_index');
  $q->condition('field_user_retired', NULL, '=');

  if (isset(drupal_get_query_parameters()['parliament'])) {
    $term = taxonomy_term_load(drupal_get_query_parameters()['parliament']);
    $q->condition('field_user_parliament', $term->tid);
    $q->condition('field_user_roles_for_view_mode_s', _pw_globals_politician_search_role_condition($term));
  }

  if (isset(drupal_get_query_parameters()['keys'])) {
    $q->keys(drupal_get_query_parameters()['keys']);
  }

  $response = $q
    ->sort('field_has_picture', 'DESC')
    ->sort('field_user_qanda_ratio', 'DESC')
    ->sort('field_user_lname')
    ->sort('search_api_relevance')
    ->range(pager_find_page() * $limit, $limit)
    ->execute();

  if ($response['result count'] > 0) {
    pager_default_initialize($response['result count'], $limit);
    $build = entity_view('user', pw_userarchives_politician_load_multiple(array_keys($response['results'])), 'tile');
    $build['user']['#theme_wrappers'] = ['container__tiles'];
    $build['pager'] = [
      '#theme' => 'pager',
      '#weight' => 5,
    ];
  }
  else {
    $build = [
      '#markup' => t('Sorry, there are no results matching your query.'),
    ];
  }

  return $build;
}

/**
 * Page callback: Returns number of supporters.
 */
function pw_globals_membership_count() {
  print rand(4000, 6000);
}

/**
 * Displays comments section of a node.
 *
 * @return
 *   The block render array.
 */
function pw_globals_comments_block() {
  $block = [];
  $node = menu_get_object();

  if (!$node) {
    return $block;
  }

  $block['subject'] = t('Comments');
  $block['content'] = comment_node_page_additions($node);

  return $block;
}

/**
 * Displays page title.
 *
 * @return
 *   The block render array.
 */
function pw_globals_title_block() {
  $block = [
    'subject' => t('Title'),
    'content' => drupal_get_title(),
  ];

  return $block;
}

/**
 * Displays an element for switching between legislative terms.
 *
 * @return array
 *   The block render array.
 */
function pw_globals_term_switcher_block() {
  $block = [];
  $term = menu_get_object('taxonomy_term');
  $map = menu_get_item()['map'];

  if (!$term) {
    return $block;
  }

  $q = new EntityFieldQuery();
  $q->entityCondition('entity_type', 'taxonomy_term');
  $q->entityCondition('bundle', 'parliaments');
  $q->propertyCondition('name', strtok($term->name, ' ') . '%', 'LIKE');
  $q->propertyCondition('tid', $term->tid, '<>');
  $q->propertyOrderBy('name', 'DESC');
  $result = $q->execute();

  if (!empty($result['taxonomy_term'])) {
    $options[url("$map[0]/$term->tid")] = $term->name;

    foreach (taxonomy_term_load_multiple(array_keys($result['taxonomy_term'])) as $t) {
      $options[url("$map[0]/$t->tid")] = $t->name;
    }

    $block['content'] = [
      '#theme' => 'select',
      '#options' => $options,
    ];
  }

  return $block;
}

/**
 * Provides politician search for landing pages.
 */
function pw_globals_politician_search_form_block() {
  $block = [];
  $term = menu_get_object('taxonomy_term', 2);

  if (!$term || $term->vocabulary_machine_name != 'parliaments' || !empty($term->description)) {
    return $block;
  }

  $today = new DateTime();
  $election_date = new DateTime($term->field_parliament_election[LANGUAGE_NONE][0]['value'], new DateTimeZone($term->field_parliament_election[LANGUAGE_NONE][0]['timezone']));

  if ($today > $election_date) {
    $block['subject'] = t('Find your <span>deputy</span>');
  }
  else {
    $block['subject'] = t('Find your <span>candidate</span>');
  }
  $block['content'] = drupal_get_form('pw_globals_politician_search_form', $term);

  return $block;
}

/**
 * Displays patron teaser for landing pages.
 */
function pw_globals_parliament_patron_block() {
  $block = [];
  $term = menu_get_object('taxonomy_term', 2);

  if (!$term) {
    return $block;
  }

  $today = new DateTime();
  $election_date = new DateTime($term->field_parliament_election[LANGUAGE_NONE][0]['value'], new DateTimeZone($term->field_parliament_election[LANGUAGE_NONE][0]['timezone']));

  if ($today > $election_date || !isset($term->field_parliament_patron[LANGUAGE_NONE][0]['target_id'])) {
    return $block;
  }

  $block['content'] = node_view(node_load($term->field_parliament_patron[LANGUAGE_NONE][0]['target_id']), 'teaser');

  return $block;
}


/**
 * Form constructor for the politician search form.
 */
function pw_globals_politician_search_form($form, &$form_state, $parliament_term) {
  $form['#method'] = 'get';
  $form['#action'] = 'solr-search/politician-index';

  if (strpos($parliament_term->name, 'EU') === 0) {
    $placeholder = t('Enter a locality or name');
  }
  else {
    $placeholder = t('Enter a postal code, locality or name');
  }

  $form['keys'] = [
    '#type' => 'textfield',
    '#title' =>  t('Keywords'),
    '#title_display' => 'invisible',
    '#attributes' => ['placeholder' => $placeholder],
  ];
  $form['submit'] = [
    '#type' => 'submit',
    '#post_render' => ['pw_globals_replace_text_with_icon'],
    '#value' => t('Search'),
  ];
  $form['parliament'] = [
    '#type' => 'hidden',
    '#value' => $parliament_term->tid,
  ];

  return $form;
}

/**
 * Post-render callback: injects icon into element.
 *
 * @param string $element
 *   The rendered element.
 *
 * @return string
 *   The modified element.
 */
function pw_globals_replace_text_with_icon($element) {
  return str_replace(t('Search'), '<i class="icon icon-search"></i>', $element);
}

/**
 * Returns the role condition for the politician search.
 *
 * If the current parliament is past the election and the current date is after
 * the beginning of the last valid period, returns the deputy role, otherwise
 * the candidate role.
 *
 * @param object $parliament_term
 *   The parliament term.
 *
 * @return int
 *   The rid of the deputy or candidate role.
 */
function _pw_globals_politician_search_role_condition($parliament_term) {
  $role_tid = PW_GLOBALS_CANDIDATE_TID;
  $items = field_get_items('taxonomy_term', $parliament_term, 'field_parliament_valid');

  if (!empty($items)) {
    $item = end($items);
    $today = new DateTime();
    $valid_from = new DateTime($item['value'], new DateTimeZone($item['timezone']));

    if ($today >= $valid_from) {
      $role_tid = PW_GLOBALS_DEPUTY_TID;
    }
  }

  return $role_tid;
}

/**
 * Checks if given profile is open for questions.
 *
 * @param object $account
 *   The account object.
 */
function _pw_is_profile_consultable($account) {
  $profile_consultable = &drupal_static(__FUNCTION__ . (isset($account->vid) ? $account->vid : ''));

  if (!isset($profile_consultable)) {
    $profile_consultable = FALSE;
    $parliament = pw_profiles_parliament($account);

    if (!$parliament) {
      return FALSE;
    }

    if (!isset($account->field_user_question_form_closed) || empty($account->field_user_question_form_closed)) {
      if (_pw_is_parliament_active($parliament)) {
        if (_pw_user_has_role($account, 'Candidate')) {
          $date_election = field_get_items('taxonomy_term', $parliament, 'field_parliament_election');
          if (empty($date_election)) {
            return FALSE;
          }
          $timestamp_day_before_election = strtotime($date_election[0]['value']) - 6 * 60 * 60;
          if (time() > $timestamp_day_before_election) {
            return FALSE;
          }
        }

        $date_joined = field_get_items('user', $account, 'field_user_joined');
        $date_retired = field_get_items('user', $account, 'field_user_retired');
        if (!empty($date_joined[0]['value']) && $date_joined[0]['value'] > date('Y-m-d') || !empty($date_retired[0]['value']) && $date_retired[0]['value'] <= date('Y-m-d 00:00:00')) {
          return FALSE;
        }

        $profile_consultable = TRUE;
      }
    }
  }

  return $profile_consultable;
}

/**
 * Custom: Checks if User (Revision) has specific role.
 */
function _pw_user_has_role($user, $role) {
  $term_role = taxonomy_get_term_by_name($role, 'pw_profile_roles_for_view_mode_switch');
  $tid_role = key($term_role);
  foreach ($user->field_user_roles_for_view_mode_s[LANGUAGE_NONE] as $user_role) {
    if ($tid_role == $user_role['tid']) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Custom: Retrieve parliament term depending on currently viewed node or user.
 */
function _pw_get_current_parliament_term() {

  $term_parliament = &drupal_static(__FUNCTION__);
  if (!isset($term_parliament)) {

    $menu_item = menu_get_item();
    if ($menu_item['page_callback'] == 'views_page' || $menu_item['path'] == 'profile/%/%') {
      $terms = taxonomy_get_term_by_name(arg(1), 'parliaments');
      if (!empty($terms)) {
        $term_parliament = array_shift($terms);
        return $term_parliament;
      }
    }

    switch (arg(0)) {

      // load by archived user profile
      case 'profile':
      case 'user':
        $user = _pw_get_current_user();
        if (isset($user->field_user_parliament[LANGUAGE_NONE][0]['tid'])) {
          $term_parliament_id = $user->field_user_parliament[LANGUAGE_NONE][0]['tid'];
          $term_parliament = taxonomy_term_load($term_parliament_id);
        }
        break;

      // load by node
      case 'node':
        $node = menu_get_object();
        if (isset($node->field_parliament[LANGUAGE_NONE][0]['tid'])) {
          $term_parliament_id = $node->field_parliament[LANGUAGE_NONE][0]['tid'];
          $term_parliament = taxonomy_term_load($term_parliament_id);
        }
        break;

      // load by taxonomy
      case 'taxonomy':
        $taxonomy_term = menu_get_object('taxonomy_term', 2);
        if ($taxonomy_term->vocabulary_machine_name == 'parliaments') {
          $term_parliament = $taxonomy_term;
        } elseif (isset($taxonomy_term->field_parliament[LANGUAGE_NONE][0]['tid'])) {
          $term_parliament_id = $taxonomy_term->field_parliament[LANGUAGE_NONE][0]['tid'];
          $term_parliament = taxonomy_term_load($term_parliament_id);
        }

        break;
    }
  }

  return $term_parliament;
}

/**
 * Custom: check if parliament is active or not.
 */
function _pw_is_parliament_active($parliament = FALSE) {

  // if parliament was not set, try to retrieve it from current context
  if (!$parliament) {
    $parliament = _pw_get_current_parliament_term();
  }
  // if parliament was given as string, try to load full term
  elseif (is_string($parliament)) {
    $parliament = reset(taxonomy_get_term_by_name($parliament, 'parliaments'));
  }
  // something went wrong
  if (!$parliament) {
    return FALSE;
  }

  // run against all dates stored in parliament term
  foreach ($parliament->field_parliament_valid[LANGUAGE_NONE] as $date_parliament_valid) {
    if (_pw_is_between_dates($date_parliament_valid)) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Custom: Checks if a timestamp (date) is between start and end date of a date field
 * @param array $date_field
 *   date field with start and end date as value and value2
 * @return boolean
 */
function _pw_is_between_dates($date_field, $timestamp = FALSE) {
  if (!$timestamp) {
    $timestamp = time();
  }
  $has_no_end_date = $date_field['value'] == $date_field['value2'];
  $is_between_dates = strtotime($date_field['value']) < $timestamp && (strtotime($date_field['value2']) > $timestamp || $has_no_end_date);
  return $is_between_dates;
}

/**
 * Custom: Retrieve user depending on user or archived user is viewed.
 */
function _pw_get_current_user() {
  switch (arg(0)) {
    // load by archived user profile
    case 'profile':

      // Load uid by username and vid
      $query = db_select('user_archive_cache', 'uac');
      $query->addField('uac', 'uid');
      $query->condition('uac.user_name', arg(1));
      $query->condition('uac.vid', arg(3));
      $result = $query->execute()->fetchAssoc();
      $user = user_revision_load($result['uid'], arg(3));
      break;

    // load by user profile
    case 'user':
      $user = user_load(arg(1));
      break;
    default:
      $user = FALSE;
  }
  return $user;
}

/**
 * Custom: Retrieve parliament tag from node by nid.
 */
function _pw_get_parliament_term_tid_by_nid($nid) {

  $selected_node = node_load($nid);
  $node_type = $selected_node->type;

  switch ($node_type) {

    case 'sidejob':
      $tid = $selected_node->field_parliament[LANGUAGE_NONE][0]['tid'];
      return $tid;
      break;

    case 'committee_membership':
      $tid = $selected_node->field_parliament[LANGUAGE_NONE][0]['tid'];
      return $tid;
      break;

    case 'speech':
      $tid = $selected_node->field_parliament[LANGUAGE_NONE][0]['tid'];
      return $tid;
      break;
  }
  return FALSE;
}

/**
 * Custom: Map items of a webform submission to their components..
 */
function _pw_webform_get_keyed_fields($webform_node, $submission) {

  // query db to retrieve webform components
  $sql = "SELECT wf_comp.cid, wf_comp.form_key
  FROM webform_component wf_comp
  WHERE wf_comp.nid = :nid";
  $form_fields = db_query($sql, array(':nid' => $webform_node->nid))->fetchAllAssoc('cid');

  // map ids to relevant components
  $form_values = array();
  foreach ($form_fields as $cid => $component) {

    // set reference to submission
    $form_values[$component->form_key] = &$submission->data[$cid][0];
  }

  // return as keyed array
  return $form_values;
}

/**
 * Custom: Send Debug Mail.
 */
function _pw_send_debug_mail($subject, $body) {
  mail('debug@abgeordnetenwatch.de', $subject, print_r($body, true) . "\n\n############################\n\n" . print_r(debug_backtrace(), 1));
}

/**
 * Custom: Get terms as links primarily for listing tags.
 * @param array $terms
 *   array of terms
 * @param string $separator
 *   separator as string
 * @return string
 *   All terms linked to term page.
 */
function _pw_get_linked_terms($terms, $separator = ', ') {
  return implode($separator, array_map(function($term) {
      return l($term['taxonomy_term']->name, 'taxonomy/term/' . $term['taxonomy_term']->tid);
    }, $terms));
}

/**
 * Custom: Helper, get fullname form user object.
 * @param object $user
 *   user object
 * @return string
 *   Fullname of user.
 */
function _pw_get_fullname($user) {
  if (!empty($user)) {
    $title = field_get_items('user', $user, 'field_user_title');
    $first_name = field_get_items('user', $user, 'field_user_fname');
    $last_name = field_get_items('user', $user, 'field_user_lname');
    return trim($title[0]['value'] . ' ' . $first_name[0]['value'] . ' ' . $last_name[0]['value']);
  }
}

/**
 * Custom: Helper to load only actual profiles from user archive cache
 * @param SelectQuery $query
 *   query object by reference
 */
function _pw_uac_add_conditions(&$query, $conditions = array()) {
  foreach ($query->getTables() as $index => $table) {
    if ($table['table'] == 'user_archive_cache') {
      $alias_uac = $index;
    }
  }

  // table was not joined or conditions not set
  if (!isset($alias_uac) || empty($conditions) || !is_array($conditions)) {
    return FALSE;
  }

  // condition date
  if (array_key_exists('date', $conditions) && !empty($conditions['date'])) {
    $or_user_joined = db_or();
    $or_user_joined->condition($alias_uac . '.user_joined', $conditions['date'], '<');
    $or_user_joined->condition($alias_uac . '.user_joined', NULL);
    $query->condition($or_user_joined);
    $or_user_retired = db_or();
    $or_user_retired->condition($alias_uac . '.user_retired', $conditions['date'], '>');
    $or_user_retired->condition($alias_uac . '.user_retired', NULL);
    $query->condition($or_user_retired);
  }

  // condition roles
  if (array_key_exists('roles', $conditions)) {
    $query->condition($alias_uac . '.user_role', $conditions['roles']);
  }

  // condition parliament
  if (array_key_exists('parliament', $conditions)) {
    $query->condition($alias_uac . '.parliament_name', $conditions['parliament']);
  }

  // condition uid
  if (array_key_exists('uid', $conditions)) {
    $query->condition($alias_uac . '.uid', $conditions['uid']);
  }

  // condition vid
  if (array_key_exists('vid', $conditions)) {
    $query->condition($alias_uac . '.vid', $conditions['vid']);
  }

  // condition username
  if (array_key_exists('username', $conditions)) {
    $query->condition($alias_uac . '.user_name', $conditions['username']);
  }
}

/**
 * for debugging entity metadata wrapper object
 */
function _pw_wrapper_debug($w) {
  $values = array();
  foreach ($w->getPropertyInfo() as $key => $val) {
    $values[$key] = $w->$key->value();
  }
  return $values;
}

/**
 * for debugging db_select query
 * @param object $query
 *   db_select query object
 * @return string
 *   Full SQL Statement.
 */
function _pw_query_debug($query) {
  $querystring = preg_replace('/[\{|\}]/', '', $query->__toString());
  foreach ($query->getArguments() as $key => $item) {
    if (!$item) {
      $item = 'NULL';
    }
    $querystring = str_replace($key . ')', "'" . $item . "')", $querystring);
  }
  return $querystring;
}

/**
 * flattens array
 * @param array
 * @param keep_key
 * @return array $array
 */
function _pw_array_flatten($array, $keep_key = TRUE) {
  $return = array();
  foreach ($array as $key => $value) {
    if (is_array($value)) {
      $return = array_merge($return, _pw_array_flatten($value, $keep_key));
    } elseif ($keep_key) {
      $return[$key] = $value;
    } else {
      $return[] = $value;
    }
  }

  return $return;
}

/**
 * sort array items by parliament
 * @param array $options
 * @param int $parliament_tid
 * @return array $options
 */
function _pw_sort_by_parliament($options, $parliament_tid) {
  if (!empty($parliament_tid)) {
    $parliament = taxonomy_term_load($parliament_tid);
    if ($parliament) {
      $efq = new EntityFieldQuery();
      $efq->entityCondition('entity_type', 'taxonomy_term')
        ->fieldCondition('field_parliament', 'tid', $parliament_tid);
      $result = $efq->execute();
      if (isset($result['taxonomy_term'])) {
        $tids_with_parliament = array_keys($result['taxonomy_term']);
        foreach ($options as $tid => $val) {
          if (in_array($tid, $tids_with_parliament)) {
            $options = array($tid => $val . " (Parliament: " . $parliament->name . ")") + $options;
          }
        }
      }
    }
  }
  return $options;
}

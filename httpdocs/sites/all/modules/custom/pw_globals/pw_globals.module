<?php

/**
 * @file
 * Code for the PW Globals feature.
 */
include_once 'pw_globals.features.inc';

define('PW_GLOBALS_API_USER_RID', 29859578);
define('PW_GLOBALS_ADMINISTRATOR_RID', 30037204);
define('PW_GLOBALS_BLOCK_MANAGER_RID', 127500594);
define('PW_GLOBALS_CONTENT_MANAGER_RID', 51622513);
define('PW_GLOBALS_POLITICIAN_RID', 181527986);
define('PW_GLOBALS_CANDIDATE_RID', 185431326);
define('PW_GLOBALS_DEPUTY_RID', 140336230);
define('PW_GLOBALS_POLITICIAN_TID', 7027);
define('PW_GLOBALS_DEPUTY_TID', 7028);
define('PW_GLOBALS_CANDIDATE_TID', 7029);

/**
 * Implements hook_menu().
 */
function pw_globals_menu() {
  $items['admin/config/pw'] = [
    'title' => 'Parliamentwatch',
    'description' => 'Custom settings for Parliamentwatch.',
    'access arguments' => ['administer site configuration'],
    'type' => MENU_NORMAL_ITEM,
  ];
  $items['info'] = [
    'title' => 'Info',
    'page callback' => 'pw_globals_info_page',
    'access arguments' => ['access content'],
    'type' => MENU_CALLBACK,
  ];
  $items['test'] = [
    'title' => 'Test',
    'page callback' => 'pw_globals_test_page',
    'access arguments' => ['administer site configuration'],
    'type' => MENU_CALLBACK,
  ];
  $items['block/%block/%'] = [
    'title' => 'Block',
    'page callback' => 'pw_globals_block_page',
    'page arguments' => [1],
    'load arguments' => [2],
    'access arguments' => ['access content'],
    'delivery callback' => 'pw_globals_deliver_ajax_page',
  ];
  return $items;
}

/**
 * Implements hook_menu_alter().
 *
 * This prevents views from setting a wrong page argument. Apparently views
 * manipulates the menu entries of children of paths it controls.
 */
function pw_globals_menu_alter(&$items) {
  $items['admin/content/antispam']['page arguments'] = ['nodes'];
  $items['taxonomy/term/%taxonomy_term']['page callback'] = 'pw_globals_taxonomy_term_page';
  unset($items['taxonomy/term/%taxonomy_term_load']['file']);
}

/**
 * Implements hook_entity_info_alter().
 */
function pw_globals_entity_info_alter(&$entity_info) {
  $entity_info['node']['view modes']['tile'] = array(
    'label' => t('Tile'),
    'custom settings' => FALSE,
  );
  $entity_info['node']['view modes']['list_item'] = array(
    'label' => t('List item'),
    'custom settings' => FALSE,
  );
  $entity_info['node']['view modes']['embedded'] = array(
    'label' => t('Embedded'),
    'custom settings' => FALSE,
  );
  $entity_info['node']['view modes']['tabular'] = array(
    'label' => t('Tabular'),
    'custom settings' => FALSE,
  );
  $entity_info['node']['view modes']['timeline'] = array(
    'label' => t('Timeline'),
    'custom settings' => FALSE,
  );
  $entity_info['comment']['view modes']['tile'] = array(
    'label' => t('Tile'),
    'custom settings' => FALSE,
  );
  $entity_info['comment']['view modes']['embedded'] = array(
    'label' => t('Embedded'),
    'custom settings' => FALSE,
  );
  $entity_info['file']['view modes']['square_small'] = array(
    'label' => t('Square small'),
    'custom settings' => TRUE,
  );
  $entity_info['file']['view modes']['square_medium'] = array(
    'label' => t('Square medium'),
    'custom settings' => TRUE,
  );
  $entity_info['file']['view modes']['width_medium'] = array(
    'label' => t('Width medium'),
    'custom settings' => TRUE,
  );
  $entity_info['file']['view modes']['width_large'] = array(
    'label' => t('Width large'),
    'custom settings' => TRUE,
  );
}

/**
 * Implements hook_form_alter().
 */
function pw_globals_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'webform_client_form_6313') {
    $form['submitted']['user_agent']['#value'] = $_SERVER['HTTP_USER_AGENT'];
    $form['submitted']['referrer']['#value'] = $_SERVER['HTTP_REFERER'];
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function pw_globals_form_pw_globals_politician_search_form_alter(&$form, &$form_state) {
  $form['form_build_id']['#access'] = FALSE;
  $form['form_token']['#access'] = FALSE;
  $form['form_id']['#access'] = FALSE;

  if (!variable_get('pw_globals_autosuggest_enabled', FALSE)) {
    unset($form['keys']['#attributes']['data-autosuggest-url']);
  }
}

/**
 * Implements hook_comment_presave().
 */
function pw_globals_comment_presave($comment) {
  if (pw_globals_comment_is_spam($comment, $_SERVER)) {
    $comment->status = COMMENT_NOT_PUBLISHED;
  }
}

/**
 * Implements hook_block_info().
 */
function pw_globals_block_info() {
  $blocks['comments'] = [
    'info' => t('Comments'),
    'cache' => DRUPAL_NO_CACHE,
  ];
  $blocks['title'] = [
    'info' => t('Title'),
    'cache' => DRUPAL_NO_CACHE,
  ];
  $blocks['politician_search_form'] = [
    'info' => 'Politician search form',
    'cache' => DRUPAL_NO_CACHE,
  ];
  $blocks['parliament_patron'] = [
    'info' => 'Parliament patron teaser',
    'cache' => DRUPAL_CACHE_PER_ROLE | DRUPAL_CACHE_PER_PAGE,
  ];
  $blocks['testimonial'] = [
    'info' => 'Testimonial teaser',
    'cache' => DRUPAL_CACHE_PER_ROLE | DRUPAL_CACHE_PER_PAGE,
  ];
  $blocks['election_teaser'] = [
    'info' => 'Election teaser',
    'cache' => DRUPAL_CACHE_PER_ROLE | DRUPAL_CACHE_PER_PAGE,
  ];
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function pw_globals_block_view($delta = '') {
  switch ($delta) {
    case 'comments':
      return pw_globals_comments_block();
    case 'title':
      return pw_globals_title_block();
    case 'politician_search_form':
      return pw_globals_politician_search_form_block();
    case 'parliament_patron':
      return pw_globals_parliament_patron_block();
    case 'testimonial':
      return pw_globals_testimonial_block();
    case 'election_teaser':
      return pw_globals_election_teaser_block();
    default:
      return [];
  }
}

/**
 * Implements hook_filter_info().
 */
function pw_globals_filter_info() {
  $filters['filter_encrypt'] = [
    'title' => t('Encrypt marked strings'),
    'description' => t('Makes strings illegible unless viewed with the matching font.'),
    'process callback' => '_pw_globals_filter_encrypt',
  ];
  return $filters;
}

/**
 * Implements hook_filter_info_alter().
 */
function pw_globals_filter_info_alter(&$info) {
  $info['filter_url']['process callback'] = '_pw_globals_filter_url';
}

/**
 * Page callback: Renders a page that demonstrates visual elements.
 */
function pw_globals_test_page() {
  return 'Lorem ipsum dolor sit...';
}

/**
 * Page callback: Displays listing of nodes in info menu.
 */
function pw_globals_info_page() {
  $build = [];
  $build['#theme_wrappers'] = ['container__tiles'];

  foreach (menu_tree_page_data('info-menu') as $link) {
    $node = node_load(substr($link['link']['link_path'], 5));
    $build[$node->nid][] = [
      '#theme' => 'html_tag',
      '#tag' => 'h2',
      '#value' => check_plain($node->title)
    ];

    foreach ($link['below'] as $child) {
      $build[$node->nid][] = node_view(node_load(substr($child['link']['link_path'], 5)), 'tile');
    }
  }

  return $build;
}

/**
 * Page callback: Displays taxonomy term pages.
 *
 * Displays terms of selected vocabularies and hides the remainder.
 */
function pw_globals_taxonomy_term_page($term) {
  if ($term->vocabulary_machine_name == 'parliaments') {
    if (pw_globals_parliament_is_funded($term)) {
      // Ensure side effects of taxonomy_term_view like generation of meta tags
      // are triggered.
      taxonomy_term_view($term);
      return '';
    }
    else {
      return taxonomy_term_view($term);
    }
  }
  elseif (in_array($term->vocabulary_machine_name, ['blogcategories', 'blogtags', 'topics'])) {
    $build = taxonomy_term_view($term);
    $nids = taxonomy_select_nodes($term->tid, TRUE, variable_get('default_nodes_main', 12));

    if ($nids) {
      $nodes = node_load_multiple($nids);
      $build = node_view_multiple($nodes, 'tile');
      $build['#theme_wrappers'] = ['container__tiles'];
      $build['pager'] = [
        '#theme' => 'pager',
        '#weight' => 5,
      ];
    }
    else {
      $build['no_content'] = [
        '#prefix' => '<p>',
        '#markup' => t('There is currently no content classified with this term.'),
        '#suffix' => '</p>',
      ];
    }

    return $build;
  }
  else {
    return MENU_NOT_FOUND;
  }
}

/**
 * Page callback: Delivers rendered block.
 *
 * @param object $block
 *   The block.
 *
 * @return array
 *   The block render array.
 */
function pw_globals_block_page($block) {
  if (isset(drupal_get_query_parameters()['path'])) {
    $_GET['q'] = drupal_lookup_path('source', drupal_get_query_parameters()['path']);
    unset($_GET['path']);
    menu_set_item(current_path(), menu_get_item($_GET['q']));
  }
  return _block_get_renderable_array(_block_render_blocks([$block]));
}

/**
 * Delivery callback:
 *
 * @param mixed $page_callback_result
 *   The result of a page callback. Can be one of:
 *   - NULL: to indicate no content.
 *   - An integer menu status constant: to indicate an error condition.
 *   - A string of HTML content.
 *   - A renderable array of content.
 */
function pw_globals_deliver_ajax_page($page_callback_result) {
  // Only render content.
  $content = drupal_render($page_callback_result);
  $title = drupal_get_title();

  // Add CSS and JS files and basic markup.
  $html = '<html><head><title>' . $title . '</title>';
  $html .= '<meta http-equiv="Content-Type" content="text/html; charset=utf-8">';
  $html .= drupal_get_css() . drupal_get_js() . '</head>';
  $html .= '<body class="jquery-ajax-load">' . $content . '</body></html>';
  print $html;

  // Perform end-of-request tasks.
  drupal_page_footer();
}

/**
 * Displays comments section of a node.
 *
 * @return array
 *   The block render array.
 */
function pw_globals_comments_block() {
  $block = [];
  $node = menu_get_object();

  if (!$node) {
    return $block;
  }

  $block['subject'] = t('Comments');
  $block['content'] = comment_node_page_additions($node);

  return $block;
}

/**
 * Displays page title.
 *
 * @return array
 *   The block render array.
 */
function pw_globals_title_block() {
  $block = [
    'subject' => t('Title'),
    'content' => drupal_get_title(),
  ];

  return $block;
}

/**
 * Displays politician search for landing pages.
 *
 * @return array
 *   The block render array.
 */
function pw_globals_politician_search_form_block() {
  $block = [];
  $term = menu_get_object('taxonomy_term', 2);

  if (!$term || $term->vocabulary_machine_name != 'parliaments' || !empty($term->description)) {
    return $block;
  }

  if (_pw_globals_politician_search_role_condition($term) == 'deputies') {
    $block['subject'] = t('Find your <span>deputy</span>');
    $teaser = t('Ask your questions to your deputies and find out about voting results and committee memberships.');
  }
  else {
    $block['subject'] = t('Find your <span>candidate</span>');
    $teaser = t('Ask your questions and find out about your direct candidates for the upcoming elections!', ['@parliament' => $term->name], ['context' => $term->name]);
  }
  $block['content']['form'] = drupal_get_form('pw_globals_politician_search_form', $term);
  $block['content']['teaser'] = [
    '#theme' => 'html_tag',
    '#tag' => 'p',
    '#value' => $teaser,
  ];
  return $block;
}

/**
 * Displays patron teaser for landing pages.
 *
 * @return array
 *   The block render array.
 */
function pw_globals_parliament_patron_block() {
  $block = [];
  $term = menu_get_object('taxonomy_term', 2);

  if (!$term || $term->vocabulary_machine_name != 'parliaments') {
    return $block;
  }

  if (!isset($term->field_parliament_election[LANGUAGE_NONE][0]['value'])) {
    return $block;
  }

  if (!isset($term->field_parliament_patron[LANGUAGE_NONE][0]['target_id'])) {
    return $block;
  }

  $block['content'] = node_view(node_load($term->field_parliament_patron[LANGUAGE_NONE][0]['target_id']), 'teaser');

  return $block;
}

/**
 * Displays testimonial teaser for landing pages.
 *
 * @return array
 *   The block render array.
 */
function pw_globals_testimonial_block() {
  $block = [];
  $type = 'pw_testimonial';
  $nodes = node_load_multiple([], ['type' => $type, 'promote' => NODE_PROMOTED, 'status' => NODE_PUBLISHED]);
  if (!empty($nodes)) {
    $block['content'] = node_view(reset($nodes),'full');
  }
  return $block;
}

/**
 * Displays election teaser for landing pages.
 *
 * The content of the block is defined in the template file.
 * Beware the $block['content'] cannot be empty, otherwise the block will not be
 * displayed.
 * 
 * @return array
 *   The block render array.
 */
function pw_globals_election_teaser_block() {
  $block = [];
  $block['content'] = ' ';
  return $block;
}

/**
 * Form constructor for the politician search form.
 */
function pw_globals_politician_search_form($form, &$form_state, $parliament_term) {
  $role_condition = _pw_globals_politician_search_role_condition($parliament_term);

  $form['#action'] = url("profiles/$parliament_term->tid/$role_condition");
  $form['#method'] = 'get';

  if (strpos($parliament_term->name, 'EU') === 0) {
    $placeholder = t('Enter a locality or name');
  }
  else {
    $placeholder = t('Enter a postal code, locality or name');
  }

  $form['keys'] = [
    '#type' => 'textfield',
    '#title' =>  t('Keywords'),
    '#title_display' => 'invisible',
    '#attributes' => [
      'data-autosuggest-url' => "profiles/$parliament_term->tid/$role_condition/autocomplete",
      'placeholder' => $placeholder,
      'type' => 'search',
    ],
    '#autocomplete' => 'off',
  ];
  $form['submit'] = [
    '#type' => 'submit',
    '#post_render' => ['pw_globals_replace_text_with_icon'],
    '#value' => t('Search'),
  ];

  return $form;
}

/**
 * Post-render callback: injects icon into element.
 *
 * @param string $element
 *   The rendered element.
 *
 * @return string
 *   The modified element.
 */
function pw_globals_replace_text_with_icon($element) {
  return str_replace(t('Search'), '<i class="icon icon-search"></i>', $element);
}

/**
 * Returns the parliament term associated with the given node.
 *
 * @param object $node
 *   The node object.
 *
 * @return object
 *   The parliament term.
 */
function pw_globals_parliament($node) {
  $parliament_term = NULL;
  $items = field_get_items('node', $node, 'field_parliament');

  if ($items) {
    $parliament_term = taxonomy_term_load($items[0]['tid']);
  }

  return $parliament_term;
}

/**
 * Returns TRUE if the given parliament is funded, FALSE otherwise.
 *
 * If the given term is not a parliament term returns NULL.
 *
 * @param object $term
 *   The parliament term.
 *
 * @return bool
 *   TRUE if the given parliament is funded, FALSE otherwise
 */
function pw_globals_parliament_is_funded($term) {
  if ($term->vocabulary_machine_name != 'parliaments') {
    return NULL;
  }
  elseif (empty($term->description)) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Returns all current parliaments.
 *
 * @return array
 *   The current parliaments.
 */
function pw_globals_current_parliaments() {
  $q = db_select('taxonomy_term_data', 'parliament');
  $q->leftJoin('field_data_field_parliament_previous', 'previous', 'parliament.tid = previous.field_parliament_previous_tid');
  $q->fields('parliament', ['tid']);
  $q->condition('vid', 18);
  $q->isNull('previous.field_parliament_previous_tid');

  return taxonomy_term_load_multiple($q->execute()->fetchCol());
}

/**
 * Returns revision of user object associated with the given node.
 *
 * @param $node
 *   The node object.
 *
 * @return object
 *   The user (revision) object.
 */
function pw_globals_politician($node) {
  $politician = NULL;
  $items = field_get_items('node', $node, 'field_politician');

  if ($items) {
    $query = db_select('user_archive_cache', 'uac')
      ->fields('uac', ['uid', 'vid']);

    _pw_uac_add_conditions($query, array(
        'parliament' => pw_globals_parliament($node)->name,
        'roles' => 'deputy',
        'uid' => $node->field_politician[LANGUAGE_NONE][0]['target_id'],
      )
    );

    $result = $query->execute()->fetchAssoc();
    $politician = user_revision_load($result['uid'], $result['vid']);
  }

  return $politician;
}

/**
 * Returns TRUE if the submission is considered spam, FALSE otherwise.
 *
 * @param string $content_type
 *   Node or comment.
 * @param object $content
 *   The node or comment.
 *
 * @return bool
 *   TRUE if the submission is considered spam, FALSE otherwise.
 */
function pw_globals_comment_is_spam($comment, $server_vars) {
  if (!variable_get('pw_globals_antispam_enabled', TRUE)) {
    return FALSE;
  }

  if (in_array($comment->node_type, variable_get('pw_globals_antispam_exclude', []))) {
    return FALSE;
  }

  $api_key = variable_get('pw_globals_antispam_api_key', '');

  if (empty($api_key)) {
    return FALSE;
  }

  $is_test = variable_get('pw_globals_antispam_is_test', FALSE);
  $url = "https://$api_key.rest.akismet.com/1.1/comment-check";
  $data = http_build_query(_pw_globals_antispam_prepare_comment_data($comment, $server_vars, $is_test));
  $headers = ['Content-Type' => 'application/x-www-form-urlencoded'];
  $response = drupal_http_request($url, ['method' => 'POST', 'headers' => $headers, 'data' => $data, 'timeout' => 5.0]);

  if (isset($response->error)) {
    watchdog('pw_globals', 'Checking a comment for spam failed: @error.', ['@error' => $response->error], WATCHDOG_WARNING);
    return TRUE;
  }

  return ($response->data == 'false') ? FALSE : TRUE;
}

/**
 * Returns the role condition for the politician search.
 *
 * If the current parliament is past the election and the current date is after
 * the beginning of the last valid period, returns "deputies", otherwise
 * "candidates".
 *
 * @param object $parliament_term
 *   The parliament term.
 *
 * @return string
 *   The URL element for the deputy or candidate role.
 */
function _pw_globals_politician_search_role_condition($parliament_term) {
  $role_condition = 'candidates';
  $items = field_get_items('taxonomy_term', $parliament_term, 'field_parliament_valid');

  if (!empty($items)) {
    $item = end($items);
    $today = new DateTime();
    $valid_from = new DateTime($item['value'], new DateTimeZone($item['timezone']));

    if ($today >= $valid_from) {
      $role_condition = 'deputies';
    }
  }

  return $role_condition;
}

/**
 * Checks if given profile is open for questions.
 *
 * @param object $account
 *   The account object.
 */
function _pw_is_profile_consultable($account) {
  $profile_consultable = &drupal_static(__FUNCTION__ . (isset($account->vid) ? $account->vid : ''));

  if (!isset($profile_consultable)) {
    $profile_consultable = FALSE;
    $parliament = pw_profiles_parliament($account);

    if (!$parliament) {
      return FALSE;
    }

    if (!isset($account->field_user_question_form_closed) || empty($account->field_user_question_form_closed)) {
      if (_pw_is_parliament_active($parliament)) {
        if (_pw_user_has_role($account, 'Candidate')) {
          $date_election = field_get_items('taxonomy_term', $parliament, 'field_parliament_election');
          if (empty($date_election)) {
            return FALSE;
          }
          $timestamp_day_before_election = strtotime($date_election[0]['value']) - 6 * 60 * 60;
          if (time() > $timestamp_day_before_election) {
            return FALSE;
          }
        }

        $date_joined = field_get_items('user', $account, 'field_user_joined');
        $date_retired = field_get_items('user', $account, 'field_user_retired');
        if (!empty($date_joined[0]['value']) && $date_joined[0]['value'] > date('Y-m-d') || !empty($date_retired[0]['value']) && $date_retired[0]['value'] <= date('Y-m-d 00:00:00')) {
          return FALSE;
        }

        $profile_consultable = TRUE;
      }
    }
  }

  return $profile_consultable;
}

/**
 * Returns TRUE if the given account has the given role, FALSE otherwise.
 *
 * @param type $account
 *   The user object.
 * @param string $role
 *   The role.
 *
 * @return bool
 *   TRUE if the given account has the given role, FALSE otherwise.
 */
function _pw_user_has_role($account, $role) {
  $role_term = taxonomy_get_term_by_name($role, 'pw_profile_roles_for_view_mode_switch');
  $role_tid = key($role_term);
  $items = field_get_items('user', $account, 'field_user_roles_for_view_mode_s');

  if (!$items) {
    return FALSE;
  }
  else {
    return in_array($role_tid, array_column($items, 'tid'));
  }
}

/**
 * Returns the parliament of the current context.
 *
 * Depending on the URL the parliament will either be the loaded menu object,
 * a taxonomy term referenced by the loaded menu object or a configurable
 * default.
 *
 * @return object
 *   The parliament term.
 *
 * @deprecated
 */
function _pw_get_current_parliament_term() {
  switch (arg(0)) {
    case 'profile':
      $map = menu_get_item()['original_map'];
      $term_parliament = pw_profiles_parliament(user_revision_load($map[1], $map[3]));
      break;
    case 'user':
      $term_parliament = pw_profiles_parliament(menu_get_object('user'));
      break;
    case 'node':
      $node = menu_get_object();
      if (isset($node->field_parliament[LANGUAGE_NONE][0]['tid'])) {
        $term_parliament = taxonomy_term_load($node->field_parliament[LANGUAGE_NONE][0]['tid']);
      }
      break;
    case 'taxonomy':
      $taxonomy_term = menu_get_object('taxonomy_term', 2);
      if ($taxonomy_term->vocabulary_machine_name == 'parliaments') {
        $term_parliament = $taxonomy_term;
      }
      elseif (isset($taxonomy_term->field_parliament[LANGUAGE_NONE][0]['tid'])) {
        $term_parliament = taxonomy_term_load($taxonomy_term->field_parliament[LANGUAGE_NONE][0]['tid']);
      }
      break;
    case 'profiles':
    case 'petitions':
    case 'polls':
    case 'dialogues':
    case 'election-manifestos':
      $term_parliament = menu_get_object('taxonomy_term', 1);
      break;
    default:
      $term_parliament = taxonomy_term_load(variable_get('pw_globals_default_parliament_tid', 26909));
  }

  return $term_parliament;
}

/**
 * Custom: check if parliament is active or not.
 *
 * @deprecated
 */
function _pw_is_parliament_active($parliament = FALSE) {

  // if parliament was not set, try to retrieve it from current context
  if (!$parliament) {
    $parliament = _pw_get_current_parliament_term();
  }
  // if parliament was given as string, try to load full term
  elseif (is_string($parliament)) {
    $parliament = reset(taxonomy_get_term_by_name($parliament, 'parliaments'));
  }
  // something went wrong
  if (!$parliament) {
    return FALSE;
  }

  // run against all dates stored in parliament term
  foreach ($parliament->field_parliament_valid[LANGUAGE_NONE] as $date_parliament_valid) {
    if (_pw_is_between_dates($date_parliament_valid)) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Custom: Checks if a timestamp (date) is between start and end date of a date field
 * @param array $date_field
 *   date field with start and end date as value and value2
 * @return boolean
 */
function _pw_is_between_dates($date_field, $timestamp = FALSE) {
  if (!$timestamp) {
    $timestamp = time();
  }
  $has_no_end_date = $date_field['value'] == $date_field['value2'];
  $is_between_dates = strtotime($date_field['value']) < $timestamp && (strtotime($date_field['value2']) > $timestamp || $has_no_end_date);
  return $is_between_dates;
}

/**
 * Custom: Retrieve user depending on user or archived user is viewed.
 *
 * @deprecated
 */
function _pw_get_current_user() {
  switch (arg(0)) {
    // load by archived user profile
    case 'profile':

      // Load uid by username and vid
      $query = db_select('user_archive_cache', 'uac');
      $query->addField('uac', 'uid');
      $query->condition('uac.user_name', arg(1));
      $query->condition('uac.vid', arg(3));
      $result = $query->execute()->fetchAssoc();
      $user = user_revision_load($result['uid'], arg(3));
      break;

    // load by user profile
    case 'user':
      $user = user_load(arg(1));
      break;
    default:
      $user = FALSE;
  }
  return $user;
}

/**
 * Custom: Map items of a webform submission to their components..
 */
function _pw_webform_get_keyed_fields($webform_node, $submission) {

  // query db to retrieve webform components
  $sql = "SELECT wf_comp.cid, wf_comp.form_key
  FROM webform_component wf_comp
  WHERE wf_comp.nid = :nid";
  $form_fields = db_query($sql, array(':nid' => $webform_node->nid))->fetchAllAssoc('cid');

  // map ids to relevant components
  $form_values = array();
  foreach ($form_fields as $cid => $component) {

    // set reference to submission
    $form_values[$component->form_key] = &$submission->data[$cid][0];
  }

  // return as keyed array
  return $form_values;
}

/**
 * Custom: Send Debug Mail.
 *
 * @deprecated
 */
function _pw_send_debug_mail($subject, $body) {
  mail('debug@abgeordnetenwatch.de', $subject, print_r($body, true) . "\n\n############################\n\n" . print_r(debug_backtrace(), 1));
}

/**
 * Custom: Helper, get fullname form user object.
 * @param object $user
 *   user object
 * @return string
 *   Fullname of user.
 */
function _pw_get_fullname($user) {
  $fullname = '';

  if (!empty($user)) {
    $title = field_get_items('user', $user, 'field_user_prefix');
    $first_name = field_get_items('user', $user, 'field_user_fname');
    $last_name = field_get_items('user', $user, 'field_user_lname');

    if ($title) {
      $fullname .= $title[0]['value'] . ' ';
    }

    $fullname .= $first_name[0]['value'] . ' ' . $last_name[0]['value'];
  }

  return trim($fullname);
}

/**
 * Custom: Helper to load only actual profiles from user archive cache
 * @param SelectQuery $query
 *   query object by reference
 */
function _pw_uac_add_conditions(&$query, $conditions = array()) {
  foreach ($query->getTables() as $index => $table) {
    if ($table['table'] == 'user_archive_cache') {
      $alias_uac = $index;
    }
  }

  // table was not joined or conditions not set
  if (!isset($alias_uac) || empty($conditions) || !is_array($conditions)) {
    return FALSE;
  }

  // condition date
  if (array_key_exists('date', $conditions) && !empty($conditions['date'])) {
    $or_user_joined = db_or();
    $or_user_joined->condition($alias_uac . '.user_joined', $conditions['date'], '<');
    $or_user_joined->condition($alias_uac . '.user_joined', NULL);
    $query->condition($or_user_joined);
    $or_user_retired = db_or();
    $or_user_retired->condition($alias_uac . '.user_retired', $conditions['date'], '>');
    $or_user_retired->condition($alias_uac . '.user_retired', NULL);
    $query->condition($or_user_retired);
  }

  // condition roles
  if (array_key_exists('roles', $conditions)) {
    $query->condition($alias_uac . '.user_role', $conditions['roles']);
  }

  // condition parliament
  if (array_key_exists('parliament', $conditions)) {
    $query->condition($alias_uac . '.parliament_name', $conditions['parliament']);
  }

  // condition uid
  if (array_key_exists('uid', $conditions)) {
    $query->condition($alias_uac . '.uid', $conditions['uid']);
  }

  // condition vid
  if (array_key_exists('vid', $conditions)) {
    $query->condition($alias_uac . '.vid', $conditions['vid']);
  }

  // condition username
  if (array_key_exists('username', $conditions)) {
    $query->condition($alias_uac . '.user_name', $conditions['username']);
  }
}

/**
 * flattens array
 * @param array
 * @param keep_key
 * @return array $array
 */
function _pw_array_flatten($array, $keep_key = TRUE) {
  $return = array();
  foreach ($array as $key => $value) {
    if (is_array($value)) {
      $return = array_merge($return, _pw_array_flatten($value, $keep_key));
    } elseif ($keep_key) {
      $return[$key] = $value;
    } else {
      $return[] = $value;
    }
  }

  return $return;
}

/**
 * Implements callback_filter_process().
 *
 * Encrypts content of crypt tags in the given text.
 *
 * @param string $text
 *   The text.
 *
 * @return string
 *   The filtered text.
 */
function _pw_globals_filter_encrypt($text) {
  $callback = function ($matches) {
    $match = empty($matches[4])?$matches[2]:$matches[4];
    return '<span class="crypto-font">' . str_rot13($match) . '</span>';
  };
  $pattern = ['(<crypt>(.*?)<\/crypt>)', '(&lt;crypt&gt;(.*?)&lt;\/crypt&gt;)'];
  return preg_replace_callback('/'.implode('|', $pattern).'/i', $callback, $text);
}

/**
 * Implements callback_filter_process().
 *
 * Converts text into hyperlinks automatically.
 *
 * This filter identifies and makes clickable three types of "links".
 * - URLs like http://example.com.
 * - E-mail addresses like name@example.com.
 * - Web addresses without the "http://" protocol defined, like www.example.com.
 * Each type must be processed separately, as there is no one regular
 * expression that could possibly match all of the cases in one pass.
 */
function _pw_globals_filter_url($text, $filter) {
  // Tags to skip and not recurse into.
  $ignore_tags = 'a|script|style|code|pre';

  // Pass length to regexp callback.
  _filter_url_trim(NULL, $filter->settings['filter_url_length']);

  // Create an array which contains the regexps for each type of link.
  // The key to the regexp is the name of a function that is used as
  // callback function to process matches of the regexp. The callback function
  // is to return the replacement for the match. The array is used and
  // matching/replacement done below inside some loops.
  $tasks = array();

  // Prepare protocols pattern for absolute URLs.
  // check_url() will replace any bad protocols with HTTP, so we need to support
  // the identical list. While '//' is technically optional for MAILTO only,
  // we cannot cleanly differ between protocols here without hard-coding MAILTO,
  // so '//' is optional for all protocols.
  // @see filter_xss_bad_protocol()
  $protocols = variable_get('filter_allowed_protocols', array('ftp', 'http', 'https', 'irc', 'mailto', 'news', 'nntp', 'rtsp', 'sftp', 'ssh', 'tel', 'telnet', 'webcal'));
  $protocols = implode(':(?://)?|', $protocols) . ':(?://)?';

  $valid_url_path_characters = "[\p{L}\p{M}\p{N}!\*\';:=\+,\.\$\/%#\[\]\-_~@&]";

  // Allow URL paths to contain balanced parens
  // 1. Used in Wikipedia URLs like /Primer_(film)
  // 2. Used in IIS sessions like /S(dfd346)/
  $valid_url_balanced_parens = '\(' . $valid_url_path_characters . '+\)';

  // Valid end-of-path characters (so /foo. does not gobble the period).
  // 1. Allow =&# for empty URL parameters and other URL-join artifacts
  $valid_url_ending_characters = '[\p{L}\p{M}\p{N}:_+~#=/]|(?:' . $valid_url_balanced_parens . ')';

  $valid_url_query_chars = '[a-zA-Z0-9!?\*\'@\(\);:&=\+\$\/%#\[\]\-_\.,~|]';
  $valid_url_query_ending_chars = '[a-zA-Z0-9_&=#\/]';

  //full path
  //and allow @ in a url, but only in the middle. Catch things like http://example.com/@user/
  $valid_url_path = '(?:(?:' . $valid_url_path_characters . '*(?:' . $valid_url_balanced_parens . $valid_url_path_characters . '*)*' . $valid_url_ending_characters . ')|(?:@' . $valid_url_path_characters . '+\/))';

  // Prepare domain name pattern.
  // The ICANN seems to be on track towards accepting more diverse top level
  // domains, so this pattern has been "future-proofed" to allow for TLDs
  // of length 2-64.
  $domain = '(?:[\p{L}\p{M}\p{N}._+-]+\.)?[\p{L}\p{M}]{2,64}\b';
  $ip = '(?:[0-9]{1,3}\.){3}[0-9]{1,3}';
  $auth = '[\p{L}\p{M}\p{N}:%_+*~#?&=.,/;-]+@';
  $trail = '(' . $valid_url_path . '*)?(\\?' . $valid_url_query_chars . '*' . $valid_url_query_ending_chars . ')?';

  // Match absolute URLs.
  $url_pattern = "(?:$auth)?(?:$domain|$ip)/?(?:$trail)?";
  $pattern = "`((?:$protocols)(?:$url_pattern))`u";
  $tasks['_pw_globals_url_parse_full_links'] = $pattern;

  // Match email addresses.
  $url_pattern = "[\p{L}\p{M}\p{N}._+-]{1,254}@(?:$domain)";
  $pattern = "`($url_pattern)`u";
  $tasks['_filter_url_parse_email_links'] = $pattern;

  // Match www domains.
  $url_pattern = "www\.(?:$domain)/?(?:$trail)?";
  $pattern = "`($url_pattern)`u";
  $tasks['_pw_globals_url_parse_partial_links'] = $pattern;

  // Each type of URL needs to be processed separately. The text is joined and
  // re-split after each task, since all injected HTML tags must be correctly
  // protected before the next task.
  foreach ($tasks as $task => $pattern) {
    // HTML comments need to be handled separately, as they may contain HTML
    // markup, especially a '>'. Therefore, remove all comment contents and add
    // them back later.
    _filter_url_escape_comments('', TRUE);
    $text = preg_replace_callback('`<!--(.*?)-->`s', '_filter_url_escape_comments', $text);

    // Split at all tags; ensures that no tags or attributes are processed.
    $chunks = preg_split('/(<.+?>)/is', $text, -1, PREG_SPLIT_DELIM_CAPTURE);
    // PHP ensures that the array consists of alternating delimiters and
    // literals, and begins and ends with a literal (inserting NULL as
    // required). Therefore, the first chunk is always text:
    $chunk_type = 'text';
    // If a tag of $ignore_tags is found, it is stored in $open_tag and only
    // removed when the closing tag is found. Until the closing tag is found,
    // no replacements are made.
    $open_tag = '';

    for ($i = 0; $i < count($chunks); $i++) {
      if ($chunk_type == 'text') {
        // Only process this text if there are no unclosed $ignore_tags.
        if ($open_tag == '') {
          // If there is a match, inject a link into this chunk via the callback
          // function contained in $task.
          $chunks[$i] = preg_replace_callback($pattern, $task, $chunks[$i]);
        }
        // Text chunk is done, so next chunk must be a tag.
        $chunk_type = 'tag';
      }
      else {
        // Only process this tag if there are no unclosed $ignore_tags.
        if ($open_tag == '') {
          // Check whether this tag is contained in $ignore_tags.
          if (preg_match("`<($ignore_tags)(?:\s|>)`i", $chunks[$i], $matches)) {
            $open_tag = $matches[1];
          }
        }
        // Otherwise, check whether this is the closing tag for $open_tag.
        else {
          if (preg_match("`<\/$open_tag>`i", $chunks[$i], $matches)) {
            $open_tag = '';
          }
        }
        // Tag chunk is done, so next chunk must be text.
        $chunk_type = 'text';
      }
    }

    $text = implode($chunks);
    // Revert to the original comment contents
    _filter_url_escape_comments('', FALSE);
    $text = preg_replace_callback('`<!--(.*?)-->`', '_filter_url_escape_comments', $text);
  }

  return $text;
}

/**
 * Makes links out of absolute URLs.
 *
 * Callback for preg_replace_callback() within _pw_globals_filter_url().
 */
function _pw_globals_url_parse_full_links($match) {
  // The $i:th parenthesis in the regexp contains the URL.
  $i = 1;

  $match[$i] = decode_entities($match[$i]);
  $caption = check_plain(_filter_url_trim($match[$i]));
  $match[$i] = check_plain($match[$i]);
  return '<a href="' . $match[$i] . '">' . $caption . '</a>';
}

/**
 * Makes links out of domain names starting with "www."
 *
 * Callback for preg_replace_callback() within _pw_gloabls_filter_url().
 */
function _pw_globals_url_parse_partial_links($match) {
  // The $i:th parenthesis in the regexp contains the URL.
  $i = 1;

  $match[$i] = decode_entities($match[$i]);
  $caption = check_plain(_filter_url_trim($match[$i]));
  $match[$i] = check_plain($match[$i]);
  return '<a href="http://' . $match[$i] . '">' . $caption . '</a>';
}

/**
 * Prepare comment data for AntiSpam requests.
 *
 * @param object $comment
 *   The comment object.
 * @param array $server_vars
 *   The PHP server variables.
 * @param bool $is_test
 *   Whether this is for a test request or not.
 *
 * @return array
 *   The data for the AntiSpam request.
 */
function _pw_globals_antispam_prepare_comment_data($comment, $server_vars, $is_test = FALSE) {
  $content = field_view_field('comment', $comment, 'comment_body');
  $comment_data = [
    'blog' => url('<front>', ['absolute' => TRUE]),
    'blog_charset' => 'UTF-8',
    'blog_lang' => 'de',
    'comment_author' => $comment->name,
    'comment_author_email' => $comment->mail,
    'comment_author_url' => $comment->homepage,
    'comment_content' => $content['#items'][0]['value'],
    'comment_type' => 'comment',
    'is_test' => (int) $is_test,
    'permalink' => url('node/'. $comment->nid, ['fragment' => 'comment-'. $comment->cid]),
    'referrer' => $server_vars['HTTP_REFERER'],
    'user_ip' => (!empty($comment->hostname) ? $comment->hostname : ip_address()),
    'user_agent' => $server_vars['HTTP_USER_AGENT'],
  ];

  $safe_to_send = [
    'CONTENT_LENGTH',
    'CONTENT_TYPE',
    'HTTP_ACCEPT',
    'HTTP_ACCEPT_CHARSET',
    'HTTP_ACCEPT_ENCODING',
    'HTTP_ACCEPT_LANGUAGE',
    'HTTP_REFERER',
    'HTTP_USER_AGENT',
    'REMOTE_ADDR',
    'REMOTE_PORT',
    'SCRIPT_URI',
    'SCRIPT_URL',
    'SERVER_ADDR',
    'SERVER_NAME',
    'REQUEST_METHOD',
    'REQUEST_URI',
    'SCRIPT_NAME'
  ];

  foreach ($server_vars as $key => $value) {
    if (in_array($key, $safe_to_send)) {
      $comment_data[$key] = $value;
    }
  }

  return $comment_data;
}

t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Bundestag']);
t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Baden-Württemberg']);
t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Bayern']);
t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Berlin']);
t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Brandenburg']);
t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Bremen']);
t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Hamburg']);
t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Hessen']);
t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Mecklenburg-Vorpommern']);
t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Niedersachsen']);
t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Nordrhein-Westfalen']);
t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Rheinland-Pfalz']);
t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Saarland']);
t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Sachsen']);
t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Sachsen-Anhalt']);
t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Schleswig-Holstein']);
t('Ask your questions and find out about your direct candidates for the upcoming elections!', [], ['context' => 'Thüringen']);
